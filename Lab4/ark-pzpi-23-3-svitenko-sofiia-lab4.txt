Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії





Звіт до лабораторної роботи №4
з дисципліни «Аналіз та рефакторинґ коду»
на тему: «Програмна система для 3D-друку»







Виконала	
ст. гр. ПЗПІ-23-3                                                               			Світенко С.М.
Перевірив
ст. викладач катедри ПІ 					Сокорчук І.П.





Харків 2025
1 ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень116.12.251Створено та опрацьовано діаграми217.12.252Створено програмну реалізацію IOT клієнту317.12.253Завершено з програмною реалізацією та звітом


2 ЗАВДАННЯ
     Мета роботи: 
     Метою даної роботи є розробка та документування повнофункціональної IoT системи для автоматизованого управління 3D-принтером на базі мікроконтролера ESP32 з можливістю віддаленого моніторингу та керування через Backend API. 
     Система призначена для інтеграції 3D-принтера в розподілену мережу виробничих пристроїв, що дозволяє централізовано управляти чергою завдань на друк, автоматично обробляти GCode файли, контролювати витрати матеріалів та збирати статистику використання обладнання. Основними завданнями роботи є проектування архітектури IoT клієнта з урахуванням обмежень апаратної платформи ESP32, розробка ефективних алгоритмів парсингу GCode файлів для розрахунку часу друку та витрат філаменту, реалізація надійного механізму комунікації з Backend сервером через REST API з обробкою мережевих збоїв, створення інтуїтивного користувацького інтерфейсу на базі LCD дисплея та фізичних кнопок з підтримкою багатомовності, а також імплементація системи локального збору статистики для аналізу ефективності роботи принтера. 
     Розроблена система має забезпечити безперервну автономну роботу IoT пристрою з можливістю автоматичного відновлення після тимчасових збоїв мережі, ефективне використання обмежених ресурсів мікроконтролера при обробці великих GCode файлів та надання користувачу повного контролю над процесом друку через локальний інтерфейс навіть за відсутності підключення до Backend сервера.


3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 UML ДІАГРАМИ
3.1.1 Діаграма прецедентів (Use Case Diagram)
Актор: Користувач
* Перегляд головного меню
* Запуск режиму полінгу завдань
* Перегляд статистики друку
* Зміна мови інтерфейсу
* Моніторинг процесу друку
Актор: Backend API Server
* Отримання черги завдань на друк
* Відправка статусу принтера (ping)
* Завантаження GCode файлів
* Повідомлення про початок/завершення друку
Актор: 3D Принтер
* Виконання друку
* Контроль температури
* Моніторинг прогресу
* Витрата матеріалу
Взаємодії:
* "Запуск полінгу" включає: перевірку черги, відправку ping, обробку завдань
* "Обробка завдання" включає: завантаження GCode, парсинг, розрахунок витрат, валідацію, виконання, моніторинг
* Всі прецеденти розширюються "Обробкою помилок" та включають "Логування"
3.1.2 Діаграма діяльності (Activity Diagram)
Початок роботи:
1. Паралельна ініціалізація компонентів:
* LCD дисплей (I2C 20x4)
* Кнопки навігації (4 шт)
* Локалізація (EN/UA)
* API клієнт, парсер GCode, контролер принтера
2. Підключення до WiFi:
* Активація адаптера → Підключення → Отримання IP (timeout 30 сек)
3. Початковий ping:
* POST /api/Printer/{id}/ping зі статусом "idle"
Головний цикл:
Режим полінгу:
* Ping кожні 120 сек
* Перевірка черги кожні 10 сек
Обробка завдання (7 етапів):
Етап 1/7: Завантаження GCode
* Socket з'єднання, потокове завантаження (chunks 2048 байт)
* Збереження в current.gcode
Етап 2/7: Парсинг GCode
* Аналіз команд G0/G1
* Розрахунок часу друку, витрати матеріалу, шарів
Етап 3/7: Валідація матеріалу
Перевірка наявності достатньої кількості
* Етап 4/7: Старт на сервері
* POST /api/Printer/{id}/jobs/{jobId}/start
Етап 5/7: Початок друку
* Підігрів (210°C сопло, 60°C стіл)
* Запуск таймера
Етап 6/7: Моніторинг (цикл кожні 2 сек)
* Розрахунок прогресу (%), поточного шару, витрат
* Оновлення LCD, відправка ping
Перевірка на завершення (прогрес >= 100%)
Етап 7/7: Завершення
* Зупинка принтера, охолодження
* POST /api/Printer/{id}/jobs/{jobId}/finish
* Оновлення статистики, видалення файлу
Інші режими:
* Статистика: відображення метрик (завдань, матеріалу, часу)
* Зміна мови: вибір EN/UA з оновленням інтерфейсу
3.2 БІЗНЕС-ЛОГІКА СИСТЕМИ
3.2.1 Обробка завдання друку (process_job)
Вхідні дані:
* id, gCodeFilePath
* requiredMaterial: type, color, diameter, density
* estimatedMaterialInGrams, estimatedPrintTimeMinutes
Етапи:
1. Ідентифікація - вивід інформації на LCD/консоль
2. Завантаження GCode - потокове через socket (економія RAM 320 КБ)
3. Аналіз та розрахунки:
* Локальний парсинг або використання серверних оцінок
* Час друку, витрата матеріалу, шари
4. Валідація - перевірка наявності матеріалу
5. Синхронізація - POST start (зміна статусу Queued → Printing)
6. Ініціалізація друку - підігрів, запуск таймера
7. Моніторинг (цикл 2 сек):
* Опитування контролера
* Оновлення LCD: прогрес-бар, шари, час, матеріал
*  Ping кожні 120 сек
*  Перевірка помилок та завершення
8.  Завершення:
*  Зупинка, охолодження
*  Оновлення статистики
*  POST finish з результатами
*  Очищення файлів, статус "idle"
Обробка помилок:
try-except на кожному етапі
_finish_job_with_error(): логування, повідомлення сервера, статус failed
3.2.2 Життєвий цикл системи (run)
Фази:
1. Ініціалізація WiFi - активація, підключення (timeout 30 сек), отримання IP
2. Реєстрація - початковий ping "idle"
3. Інтерактивне меню - навігація кнопками Up/Down/Select/Back
4. Робочий цикл (while True):
5. Режим меню: опитування кнопок (0.1 сек), низьке енергоспоживання
6. Режим полінгу: активний пошук завдань, автоматична обробка
3.2.3 Комунікація з Backend API
Базовий метод _make_request():
* HTTP запити з таймаутами
* Серіалізація JSON
* Обов'язкове response.close() (обмеження socket на ESP32)

API методи:
* ping(status) - POST /ping, {"Status": "idle|printing|error"}
* get_queue() - GET /queue, повертає масив завдань (FIFO)
* start_job(id, time) - POST /jobs/{id}/start, {"ActualEstimatedTime": float}
* finish_job(id, success, material, error) - POST /jobs/{id}/finish
* {"IsSuccess": bool, "ActualMaterialInGrams": float, "ErrorMessage": string}
* download_file(path, dest) - GET /files/download
3.2.4 Інтерфейс користувача (MenuSystem)
Архітектура FSM:
* STATE_MAIN_MENU, STATE_POLLING, STATE_STATISTICS, STATE_LANGUAGE
* state_history для навігації "назад"
Відображення:
Головне меню:
* Рядок 0: заголовок
* Рядки 1-3: пункти (вибраний з ">")
* Прокрутка для >3 пунктів
Режим полінгу:
* Статус принтера, час з перевірки, підказка виходу
* Оновлення 0.5 сек
Статистика:
* "Total jobs: 15"
* "OK:12 Err:3"
* "Material:345.2g Time:12h"
Прогрес друку:
* Прогрес-бар: [###########---------] 58%
* "Layer: 145/250"
* "Time: 27min Material: 18g"
3.2.5 Статистика (Statistics)
Метрики:
1. Лічильники: total_jobs, successful_jobs, failed_jobs
success_rate = (successful / total) × 100%
2. Матеріал: total_material_grams
3. Час друку: total_print_time_seconds (активний друк)
4. Uptime: current_time - start_time
Життєвий цикл:
* start_job() - збереження контексту
* finish_job() - оновлення глобальних лічильників
* get_summary() - формування словника для відображення
3.3 МАТЕМАТИЧНІ МЕТОДИ
3.3.1 Парсинг GCode та розрахунок часу
Структура команди:
        G1 X100.5 Y200.3 Z0.2 E2.5 F1500
Стан парсера:
* current_position: {X, Y, Z, E}
* current_feedrate: F (mm/min)
* total_extrusion, total_time, layer_count
Алгоритм:
1. Читання по рядках, фільтрація коментарів
2. Ідентифікація G0/G1
3. Парсинг параметрів → new_position
Розрахунок часу руху:
Відстань (Евклідова метрика):
d = √[(X₂-X₁)² + (Y₂-Y₁)² + (Z₂-Z₁)²]
Час:
t = d / v = (d / feedrate) × 60
де feedrate у mm/min, конвертується в mm/sec
Розрахунок екструзії:
extrusion_delta = E_new - E_old
if extrusion_delta > 0:
    total_extrusion += extrusion_delta
Підрахунок шарів:
* Інкремент при наявності параметру Z
Складність: O(n), де n - рядків у файлі
3.3.2 Розрахунок ваги матеріалу
Вхідні параметри:
* extrusion_mm: довжина філаменту
* filament_diameter_mm: 1.75 або 3.0 мм
* density_g_cm³: PLA=1.24, ABS=1.04, PETG=1.27
Формула (циліндр):
V = π × r² × L
Де :r = diameter / 2V у мм³
Конвертація та вага:
V_cm³ = V_mm³ / 1000
W_grams = V_cm³ × density
Зведена формула:
W = (π × (d/2)² × L × ρ) / 1000
Приклад: 20 м філаменту 1.75 мм, PLA:
r = 0.875 мм
V = 3.14159 × 0.875² × 20000 = 48,117 мм³
W = 48.117 × 1.24 = 59.67 г
Точність: ±10-15% (похибки щільності, діаметру, калібрування)
3.3.3 Розрахунок прогресу друку
Прогрес за часом:
progress = (elapsed_time / estimated_duration) × 100%
progress = min(progress, 100)
Симуляція прискорення:
simulated_duration = (estimated_minutes × 60) / SPEED_MULTIPLIER
де SPEED_MULTIPLIER = 3
Час що залишився:
remaining = max(estimated_duration - elapsed, 0)
Поточний шар:
current_layer = ⌊(progress / 100) × total_layers⌋
Витрачений матеріал:
used = (progress / 100) × estimated_material
3.3.4 Температури (симуляція)
Цільові температури PLA:
Екструдер: 210°C
Стіл: 60°C
Реальний підігрів (закон Ньютона):
T(t) = T_ambient + (T_target - T_ambient) × (1 - e^(-kt))
Симуляція (лінійна):
T_n = T_target × (n / total_steps)
5 кроків по 0.2 сек = 1 сек загалом
3.3.5 Статистичні розрахунки
Коефіцієнт успіху:
success_rate = (successful_jobs / total_jobs) × 100%
Форматування часу:
hours = ⌊seconds / 3600⌋
minutes = ⌊(seconds % 3600) / 60⌋

Ключові технічні характеристики:
* Платформа: ESP32 (320 КБ RAM)
* LCD: I2C 20x4
* Інтервали: ping 120с, queue 10с, моніторинг 2с
* Формат: GCode (команди G0/G1)
* Матеріали: PLA/ABS/PETG (1.75/3.0 мм)
* Симуляція: прискорення ×3


ВИСНОВКИ
     В результаті виконаної роботи було успішно спроектовано та задокументовано IoT систему для автоматизованого управління 3D-принтером, яка повністю відповідає поставленим вимогам щодо функціональності, надійності та ефективності використання апаратних ресурсів. Розроблена архітектура системи базується на модульному підході з чітким розділенням відповідальності між компонентами, що включають модулі управління мережевими комунікаціями, парсингу GCode, контролю друку, користувацького інтерфейсу, локалізації та збору статистики. Реалізовано повний життєвий цикл обробки завдання на друк, що включає сім критичних етапів від завантаження GCode файлу до відправки детального звіту про виконання на Backend сервер, з автоматичним моніторингом прогресу друку та обробкою виняткових ситуацій на кожному етапі.
     Особлива увага була приділена оптимізації роботи з обмеженими ресурсами мікроконтролера ESP32, зокрема реалізовано потокове завантаження великих GCode файлів через низькорівневі socket з'єднання, що дозволяє обробляти файли розміром понад десять мегабайт при наявності лише 320 кілобайт оперативної пам'яті. 
     Математичні методи розрахунку часу друку базуються на точному аналізі команд руху в GCode з урахуванням Евклідової метрики для обчислення відстаней та лінійної інтерполяції швидкостей, а розрахунок ваги витраченого матеріалу використовує геометричну модель циліндра з урахуванням фізичних властивостей різних типів філаменту. Складність алгоритму парсингу становить O(n) за часом при O(1) за пам'яттю, що забезпечує ефективну обробку навіть файлів з десятками тисяч команд.
     Розроблена система збору локальної статистики дозволяє відстежувати ключові показники ефективності роботи принтера, включаючи загальну кількість виконаних завдань, коефіцієнт успішності, сумарну витрату матеріалів та час активного друку, що надає цінну інформацію для планування обслуговування обладнання та оптимізації виробничих процесів. 

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
    1. Refactoring: improving the design of existing code. Addison-Wesley Professional, 1999. 464 с.
    2. Microsoft C# Coding Conventions. URL: https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions (дата звернення: 12.12.2025);
    3. .NET Runtime Coding Style. URL: 
https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md (дата звернення: 12.12.2025);
    4. ASP.NET Core Documentation. URL: https://learn.microsoft.com/en-us/aspnet/core/ (дата звернення: 12.12.2025);
    5. StyleCop Analyzers. URL: https://github.com/DotNetAnalyzers/StyleCopAnalyzers (дата звернення: 12.12.2025);
    6. EditorConfig. URL:   https://editorconfig.org/ (дата звернення: 12.12.2025);
    7. ReSharper Code Inspection. URL:   https://www.jetbrains.com/help/resharper/Code_Analysis__Code_Inspections.html (дата звернення: 12.12.2025).


ДОДАТОК А
Відеозапис: https://youtu.be/80dCDU1tSmM
Хронологічний опис відеозапису:
0:00-1:00 — Вступ та мета роботи
1:00-3:30 — Архітектура IoT клієнта (апаратне та програмне забезпечення)
3:30-6:00 — Життєвий цикл обробки завдання (7 етапів)
6:00-8:30 — Математичні методи
6:00-7:00 — Парсинг GCode та розрахунок часу друку
7:00-7:45 — Розрахунок ваги матеріалу
7:45-8:30 — Розрахунок прогресу та температур
8:30-10:00 — Інтерфейс користувача та статистика
10:00-11:30 — Комунікація з Backend API
11:30-13:30 — Демонстрація діаграми прецедентів (Use Case)
13:30-15:30 — Демонстрація діаграми діяльності (Activity)
15:30-19:30 — Практична демонстрація роботи системи (5 хвилин)
19:30-20:00 — Висновки та результати
 

ДОДАТОК Б
Графічні матеріали



Рисунок Б.1 – Діаграма прецедентів IoT клієнта


Рисунок Б.2 – Діаграма діяльності IoT клієнта

ДОДАТОК В
Програмний код
Програмний код знаходиться за посиланням
TODO додати
15


