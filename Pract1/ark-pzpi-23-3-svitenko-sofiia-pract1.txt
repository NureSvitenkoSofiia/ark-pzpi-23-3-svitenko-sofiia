Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії



Звіт до практичного завдання №1
з дисципліни «Аналіз та рефакторинґ коду»
на тему: «Застосування правил PEP 8 і методів рефакторингу у веб-розробці на Python»







Виконав 	
ст. гр. ПЗПІ-23-3                                                               			Світенко С.М.
Перевірив
ст. викладач катедри ПІ 					Сокорчук І.П.





                                                                                     
Харків 2025
1 ІСТОРІЯ ЗМІН 
№ДатаВерсія звітуОпис змін та виправлень110.10.20250.1Написання розділу «Завдання»209.11.20250.2Написання розділу «Опис виконаної роботи»303.12.20251.0Завершено роботу над звітом


2 ЗАВДАННЯ
     Мета роботи: 
     Метою даної роботи є дослідження та систематизація практичних аспектів застосування стандарту PEP 8 та методів рефакторингу коду у контексті веб-розробки на мові програмування Python, а також визначення їх впливу на якість, читабельність та підтримуваність програмного забезпечення. Робота спрямована на вивчення основних принципів та рекомендацій стандарту PEP 8, який є загальноприйнятим керівництвом щодо стилю написання коду на Python, включаючи правила форматування, іменування змінних, функцій та класів, організації імпортів, обробки винятків та документування коду. Окрім того, метою є детальний аналіз різноманітних технік рефакторингу, таких як виділення методів, спрощення умовних конструкцій, усунення дублювання коду, оптимізація структури класів та модулів, які дозволяють покращити архітектуру існуючих веб-додатків без зміни їх зовнішньої функціональності. Важливим завданням роботи є демонстрація практичного застосування цих принципів у популярних Python веб-фреймворках, таких як Django та Flask, з наведенням конкретних прикладів рефакторингу коду контролерів, моделей, шаблонів та допоміжних функцій. Дослідження також має на меті показати, як дотримання стандартів кодування та регулярний рефакторинг сприяють покращенню командної роботи, полегшують процес Code Review, знижують кількість помилок у коді, прискорюють розробку нових функцій та спрощують підтримку проектів у довгостроковій перспективі. Кінцевою метою є формування комплексного розуміння того, як інтеграція правил PEP 8 та методів рефакторингу у процес веб-розробки на Python може суттєво підвищити професійний рівень розробників та якість створюваних ними продуктів.




3 ОПИС ВИКОНАНОЇ РОБОТИ
     У рамках практичної роботи було детально вивчено та проаналізовано правила оформлення програмного коду мовою Python для веб-розробки з використанням сучасних фреймворків. Робота базувалася на офіційному стандарті PEP 8 Style Guide for Python Code, загальноприйнятих практиках рефакторингу, описаних у роботах Мартіна Фаулера. Практична частина включала вивчення методів рефакторингу коду та використання автоматизованих інструментів перевірки відповідності стандартам, таких як pylint, flake8 та Black..
3.1 Стильові рекомендації та форматування коду
     Основою якісного коду є дотримання стандартів форматування згідно з PEP 8. Для відступів необхідно використовувати чотири пробіли замість символу табуляції. Максимальна довжина рядка не повинна перевищувати 79 символів для коду та 72 символи для коментарів і документації. Між функціями верхнього рівня та визначеннями класів має бути два порожніх рядки, між методами всередині класу один порожній рядок. Імпорти завжди розміщуються на початку файлу після коментарів та рядків документації модуля, при цьому спочатку імпортуються стандартні бібліотеки, потім сторонні пакети, а в кінці локальні модулі проекту.
     Приклад правильного форматування:
01 class UserService:
02     def __init__(self, repository):
03         self._repository = repository
04
05     async def get_user(self, user_id):
06         if user_id <= 0:
07             raise ValueError(
08                 f"User ID must be positive, got {user_id}"
09             )
10
11         return await self._repository.find_by_id(user_id)
12
13     def validate_user_data(self, user_data):
14         if not user_data.get('email'):
15             raise ValueError("Email is required")
16         return True
3.2 Конвенції найменування елементів коду
 	Правильне найменування елементів коду є критично важливим для забезпечення читабельності та підтримки програмного продукту. Було досліджено та систематизовано наступні правила згідно з PEP 8: класи, структури та методи іменуються у стилі PascalCase (наприклад, UserManager, ProcessPayment);
* класи іменуються у стилі CapWords або PascalCase (наприклад, UserManager, EmailService); 
* функції та методи пишуться у snake_case малими літерами з підкресленнями (наприклад, process_payment, get_user_data); 
* змінні та параметри функцій пишуться у snake_case (наприклад, user_name, total_amount); 
* константи пишуться великими літерами з підкресленнями (наприклад, MAX_RETRY_COUNT, DEFAULT_TIMEOUT); 
* приватні методи та атрибути класу починаються з одного підкреслення (наприклад, _logger, _process_internal); 
* модулі та пакети мають короткі імена у нижньому регістрі без підкреслень (наприклад, utils, models).
Приклад застосування конвенцій найменування:
01  from abc import ABC, abstractmethod
02  from typing import Dict, Optional
03  
04  MAX_RETRY_ATTEMPTS = 3
05  DEFAULT_CURRENCY = 'USD'
06
07  
08  class EmailService:
09      def __init__(self, smtp_host, smtp_port, logger):
10          self._smtp_host = smtp_host
11          self._smtp_port = smtp_port
12          self._logger = logger
13          self.is_enabled = True
14      
15      async def send_email(self, recipient, subject, body):
16          retry_count = 0
17          is_successful = False
18          
19          while retry_count < MAX_RETRY_ATTEMPTS and not is_successful:
20              is_successful = await self._try_send(recipient, subject, body)
21              retry_count += 1
22          
23          return {'success': is_successful, 'attempts': retry_count}
24      
25      def _validate_email(self, email):
26          if not email or '@' not in email:
27              raise ValueError(f"Invalid email address: {email}")
28          return True
29      
30      async def _try_send(self, recipient, subject, body):
31          self._validate_email(recipient)
32          # Логіка відправки листа
33          self._logger.info(f"Sending email to {recipient}")
34          return True
3.3 Організація імпортів
     Однією з важливих рекомендацій PEP 8 є правильна організація імпортів у Python-модулях. Імпорти повинні бути згруповані у три окремі блоки, розділені порожніми рядками: спочатку імпортуються модулі стандартної бібліотеки Python, потім сторонні бібліотеки та фреймворки, такі як Django, Flask або requests, і нарешті локальні модулі проекту. Кожен імпорт має розташовуватися на окремому рядку для кращої читабельності. Така організація особливо важлива у веб-проектах, які зазвичай мають велику кількість залежностей, оскільки структурований порядок імпортів дозволяє швидко побачити всі залежності модуля, спрощує навігацію по коду та допомагає своєчасно виявляти потенційні проблеми, зокрема циклічні імпорти, які можуть призвести до помилок під час виконання програми.
        01  # Стандартна бібліотека Python
        02  import datetime
        03  import json
        04
        05  # Треті бібліотеки (Django, DRF)
        06  from django.contrib.auth.decorators import login_required
        07  from django.shortcuts import render
        08  from rest_framework.views import APIView
        09
        10  # Локальні модулі проекту
        11  from .models import Order
        12  from .serializers import OrderSerializer
3.4 Принципи рефакторингу
     Рефакторинг являє собою процес зміни внутрішньої структури програмного коду без зміни його зовнішньої поведінки та функціональності. Мартін Фаулер, один з провідних експертів у галузі розробки програмного забезпечення, назвав рефакторинг дисциплiною покращення коду. Існує кілька ключових ознак, які вказують на необхідність проведення рефакторингу: функція перевищує обсяг у двадцять-тридцять рядків коду, один і той самий блок коду дублюється у кількох місцях проекту, присутні складні вкладені умовні конструкції, використовуються незрозумілі назви змінних або так звані магічні числа без пояснень, а також коли клас бере на себе занадто багато відповідальностей і порушує принцип єдиної відповідальності. При проведенні рефакторингу необхідно дотримуватися трьох основних принципів: виконувати зміни маленькими кроками з обов'язковим тестуванням після кожного кроку, забезпечувати незмінність функціональності системи під час всього процесу та прагнути до покращення читабельності і підтримуваності коду. Серед найпотужніших методів рефакторингу для веб-розробки особливу увагу заслуговує техніка Extract Method, яка дозволяє перетворювати довгі заплутані функції на зрозумілі послідовності логічних дій.
          3.4.1 Extract Method
     Одним з найбільш ефективних методів рефакторингу є Extract Method, який полягає у винесенні логічних блоків коду в окремі функції з описовими назвами. Коли функція виконує занадто багато різних операцій, частини її логіки мають бути виділені в окремі методи, кожен з яких виконує одну конкретну задачу відповідно до принципу єдиної відповідальності. Ця техніка є особливо важливою у веб-розробці, оскільки view-функції у Django або обробники маршрутів у Flask часто виконують п'ять-шість різних дій одночасно, таких як валідація даних, взаємодія з базою даних, обробка бізнес-логіки, формування відповіді та логування. Без застосування Extract Method такі функції швидко перетворюються на важко підтримувані монстри обсягом понад сто рядків коду, де складно зрозуміти логіку роботи та знайти місце можливих помилок. Виділення окремих методів робить код більш модульним, тестованим та зрозумілим, дозволяє повторно використовувати логіку в інших частинах програми та значно спрощує процес налагодження та подальшої розробки.	
01  def register(request):
02      user_data = extract_registration_data(request)
03      validation_error = validate_user_data(user_data)
04      
05      if validation_error:
06          return JsonResponse({'error': validation_error})
07      
08      user = create_user(user_data)
09      return JsonResponse({'user_id': user.id})
10
11
12  def extract_registration_data(request):
13      """Витягує дані реєстрації з запиту."""
14      return {
15          'username': request.POST['username'],
16          'email': request.POST['email'],
17          'password': request.POST['password']
18      }
19
20
21  def validate_user_data(data):
22      """Валідує дані користувача. Повертає помилку або None."""
23      if '@' not in data['email']:
24          return 'Invalid email format'
25      
26      if len(data['password']) < 8:
27          return 'Password too short'
28      
29      if not any(c.isupper() for c in data['password']):
30          return 'Password needs uppercase letter'
31      
32      return None
33
34
35  def create_user(data):
36      """Створює нового користувача."""
37      return User.objects.create_user(
38          username=data['username'],
39          email=data['email'],
40          password=data['password']
41      )
          3.4.2 Replace magic numbers
     Важливою практикою рефакторингу є заміна магічних чисел на іменовані константи з описовими назвами. Магічне число - це числовий літерал у коді, значення якого не є очевидним без додаткового контексту або пояснення. Замість використання незрозумілих конструкцій на кшталт if status == 2 або if quantity > 100 рекомендується створювати іменовані константи, наприклад if status == OrderStatus.PROCESSING або if quantity > MAX_ITEMS_PER_ORDER. Ця техніка є особливо критичною у веб-додатках, де присутня велика кількість конфігураційних значень, таких як статуси замовлень, коди помилок HTTP, ліміти запитів до API, розміри сторінок для пагінації, тайм-аути з'єднань та інші параметри системи. Без використання іменованих констант такі числа залишаються загадковими для інших розробників і навіть для автора коду через певний час, що ускладнює розуміння логіки програми, підвищує ймовірність помилок при внесенні змін та робить код менш підтримуваним у довгостроковій перспективі.
01  # constants.py
02  class OrderStatus:
03      """Статуси замовлень в системі."""
04      PENDING = 1
05      PROCESSING = 2
06      CONFIRMED = 3
07      SHIPPED = 4
08      DELIVERED = 5
09
10
11  BULK_ORDER_THRESHOLD = 1000  # мінімальна сума для оптового замовлення
12  BULK_DISCOUNT_RATE = 0.1  # 10% знижка для оптових замовлень
13
14
15  # views.py
16  def process_order(order):
17      if order.status == OrderStatus.PENDING:
18          if order.total > BULK_ORDER_THRESHOLD:
19              order.discount = order.total * BULK_DISCOUNT_RATE
20              order.status = OrderStatus.PROCESSING
21          else:
22              order.status = OrderStatus.CONFIRMED
23      return order
24
25
26  def get_pending_orders():
27      return Order.objects.filter(status=OrderStatus.PENDING) 
3.4 Обробка помилок та винятків
     Правильна обробка винятків є критично важливою для створення стабільних веб-додатків. Рекомендується ловити специфічні винятки замість використання загального except, додавати контекст до помилок для полегшення діагностики та створювати кастомні класи винятків для бізнес-логіки додатку. Python має потужну систему винятків, і для її ефективного використання необхідно дотримуватися кількох основних правил: завжди ловити конкретні типи винятків, такі як ValueError або KeyError, замість голого except, який може приховати несподівані помилки; ніколи не ігнорувати помилки мовчки без логування або обробки; додавати додатковий контекст до винятків для спрощення діагностики проблем у продакшені; створювати власні класи винятків для специфічних ситуацій у бізнес-логіці. Ця практика є особливо важливою у веб-розробці, оскільки помилки є неминучими при роботі з мережевими з'єднаннями, базами даних, зовнішніми API, файловою системою та іншими зовнішніми ресурсами. Правильна обробка винятків забезпечує стабільність додатку, дозволяє швидко виявляти та виправляти проблеми, покращує користувацький досвід завдяки зрозумілим повідомленням про помилки та запобігає витоку конфіденційної інформації через необроблені виключення. 
        01  class ValidationError(Exception):
        02      """Помилка валідації даних."""
        03      pass
        04
        05
        06  def create_discount(code, percent):
        07      """Створює новий промокод зі знижкою."""
        08      # Валідація вхідних даних
        09      if not code or len(code) < 3:
        10          raise ValidationError('Discount code must be at least 3 characters')
        11      
        12      if not 0 < percent <= 100:
        13          raise ValidationError('Discount percent must be between 1 and 100')
        14      
        15      # Перевірка унікальності
        16      try:
        17          if Discount.objects.filter(code=code).exists():
        18              raise ValidationError(f'Discount code "{code}" already exists')
        19      except DatabaseError as e:
        20          logger.error(f'Database error checking discount: {e}')
        21          raise ValidationError('Database temporarily unavailable')
        22      
        23      # Створення
        24      try:
        25          discount = Discount.objects.create(code=code, percent=percent)
        26          logger.info(f'Created discount: {code} ({percent}%)')
        27          return discount
        28      except DatabaseError as e:
        29          logger.error(f'Failed to create discount: {e}')
        30          raise ValidationError('Failed to save discount')
        31
        32
        33  # Використання в view
        34  try:
        35      discount = create_discount(code, percent)
        36      return JsonResponse({'success': True, 'id': discount.id})
        37  except ValidationError as e:
        38      return JsonResponse({'error': str(e)}, status=400)
3.5 Оптимізація продуктивності з запитами до БД
     Однією з найважливіших практик оптимізації веб-додатків на Django є правильне використання методів select_related та prefetch_related для мінімізації кількості запитів до бази даних. Django ORM може створювати проблему N+1 запитів, коли замість одного ефективного запиту виконується велика кількість окремих запитів до бази даних при ітерації по колекції об'єктів. Для вирішення цієї проблеми використовуються два основні методи: select_related, який призначений для оптимізації звичайних зв'язків ForeignKey та OneToOneField і працює шляхом виконання SQL JOIN для завантаження пов'язаних об'єктів в одному запиті, та prefetch_related, який використовується для оптимізації зв'язків ManyToMany та зворотних ForeignKey і виконує окремі запити для кожної таблиці з подальшим об'єднанням результатів на рівні Python. Ця оптимізація є критично важливою для продуктивності веб-додатків, оскільки повільні запити до бази даних безпосередньо впливають на швидкість роботи сайту, а ситуація, коли виконується сто окремих запитів замість одного оптимізованого, може призвести до катастрофічного падіння продуктивності, особливо під навантаженням з великою кількістю одночасних користувачів. 
     Приклад оптимізованого коду:
        01  def article_list(request):
        02      # select_related робить JOIN в SQL
        03      articles = Article.objects.select_related(
        04          'author',
        05          'category'
        06      ).all()
        07      
        08      # 1 запит:
        09      # SELECT * FROM articles
        10      # JOIN users ON articles.author_id = users.id
        11      # JOIN categories ON articles.category_id = categories.id
        12      
        13      result = []
        14      for article in articles:
        15          # Дані вже завантажені - немає додаткових запитів!
        16          result.append({
        17              'title': article.title,
        18              'author': article.author.name,
        19              'category': article.category.name
        20          })
        21      
        22      return JsonResponse(result, safe=False)
3.8 Документування коду
     Важливою практикою є написання docstrings для модулів, класів та функцій у стилі Google або NumPy, а також коментування складної логіки. Docstrings мають містити опис призначення коду, параметрів, типів даних та значень, що повертаються. Це значно полегшує розуміння коду іншими розробниками та його подальшу підтримку, особливо у великих веб-проектах з множиною компонентів та модулів. 
01  def process_payment(order, customer_card, amount):
02      """Обробляє платіж за замовлення з картки клієнта.
03      
04      Перевіряє достатність коштів на картці, списує суму та позначає
05      замовлення як оплачене. Всі операції виконуються в транзакції.
06      
07      Args:
08          order (Order): Об'єкт замовлення для оплати
09          customer_card (CreditCard): Картка клієнта для списання
10          amount (Decimal): Сума до списання в гривнях
11      
12      Returns:
13          bool: True якщо платіж успішний, False якщо недостатньо коштів
14      
15      Raises:
16          ValueError: Якщо amount <= 0
17          PaymentError: Якщо картка недійсна або заблокована
18      
19      Example:
20          >>> card = CreditCard.objects.get(number='1234')
21          >>> order = Order.objects.get(id=100)
22          >>> success = process_payment(order, card, Decimal('250.00'))
23          >>> if success:
24          ...     print('Payment processed')
25      """
26      if amount <= 0:
27          raise ValueError('Payment amount must be positive')
28      
29      if not customer_card.is_valid():
30          raise PaymentError('Card is invalid or expired')
31      
32      # Перевірка балансу
33      if amount > customer_card.balance:
34          logger.warning(f'Insufficient funds for order {order.id}')
35          return False
36      
37      # Виконання платежу в транзакції
38      with transaction.atomic():
39          customer_card.balance -= amount
40          customer_card.save()
41          
42          order.is_paid = True
43          order.payment_date = timezone.now()
44          order.save()
45      
46      logger.info(f'Payment processed: order {order.id}, amount {amount}')
47      return True
3.9 Інструменти забезпечення якості коду
	Для полегшення процесу дотримання стандартів PEP 8 та виявлення потенційних проблем у коді існує ряд автоматичних інструментів. Black є автоматичним форматувальником коду, який дозволяє одразу привести весь проект у відповідність до стандартів - достатньо запустити команду black . і код автоматично форматується згідно з правилами. Flake8 виступає як лінтер, що перевіряє код на відповідність PEP 8, виявляє потенційні помилки, невикористані імпорти та змінні, а також інші проблеми якості коду. Pylint надає більш детальний аналіз коду, включаючи перевірку складності функцій, дотримання конвенцій найменування та інші аспекти якості програмного забезпечення. Для веб-розробки на Django особливо корисним є Django Debug Toolbar - інструмент для профілювання та виявлення проблем з продуктивністю, зокрема проблеми N+1 запитів до бази даних, що дозволяє оперативно оптимізувати роботу додатку. Використання цих інструментів значно прискорює розробку, зменшує кількість помилок та забезпечує консистентність коду в командній роботі. 
Приклад роботи з Black:
01  # Код ДО форматування Black (неохайний, непослідовний)
02  def calculate_total(items,tax_rate=0.2,discount   = 0):
03      subtotal=sum([item['price']* item['quantity'] for item in items])
04      tax=subtotal*tax_rate
05      total=subtotal+tax-discount
06      return total
07
08
09  # Код ПІСЛЯ форматування Black (команда: black filename.py)
10  def calculate_total(items, tax_rate=0.2, discount=0):
11      subtotal = sum([item["price"] * item["quantity"] for item in items])
12      tax = subtotal * tax_rate
13      total = subtotal + tax - discount
14      return total 
Приклад роботи з flake8:
01  # Код з проблемами (flake8 виявить помилки)
02  import os
03  import sys
04  import json
05  from django.shortcuts import render
06  
07  def process_data(data):
08      result=data['value']*2
09      unused_variable = "test"
10      if result>100:
11          return True
12      return False
13
14
15  # Вивід flake8:
16  # example.py:7:19: E225 missing whitespace around operator
17  # example.py:8:5: F841 local variable 'unused_variable' is assigned but never used
18  # example.py:9:17: E225 missing whitespace around operator
19
20
21  # Виправлений код після аналізу flake8
22  from django.shortcuts import render
23
25  def process_data(data):
26      result = data['value'] * 2
27      if result > 100:
28          return True
29      return False 

ВИСНОВКИ
     У результаті виконання практичної роботи було детально вивчено та проаналізовано правила оформлення програмного коду мовою Python для веб-розробки з використанням сучасних фреймворків та інструментів. Дослідження базувалося на офіційному стандарті PEP 8, який встановлює єдині конвенції щодо форматування коду, іменування елементів, організації імпортів та документування програмних компонентів. Було встановлено, що дотримання цих стандартів є критично важливим для забезпечення читабельності коду, полегшення командної роботи та підвищення загальної якості веб-додатків. Особлива увага приділялася методам рефакторингу коду, серед яких найбільш ефективними для веб-розробки виявилися Extract Method для розбиття складних функцій на логічні блоки, Replace Magic Numbers для підвищення зрозумілості числових значень та правильна обробка винятків для забезпечення стабільності додатків. Практичне застосування цих методів на прикладах Django продемонструвало їх здатність суттєво покращувати структуру коду та його підтримуваність. Важливим результатом роботи стало ознайомлення з автоматизованими інструментами перевірки та форматування коду, такими як Black, flake8 та pylint, які дозволяють автоматизувати процес дотримання стандартів та виявлення потенційних проблем на ранніх етапах розробки. Окремо було розглянуто питання оптимізації запитів до бази даних у Django ORM з використанням методів select_related та prefetch_related, що є критично важливим для продуктивності веб-додатків під навантаженням. Отримані знання та навички щодо застосування правил PEP 8 і методів рефакторингу формують міцну основу для створення якісного, професійного коду у веб-розробці на Python та можуть бути безпосередньо застосовані у реальних проектах для підвищення їх якості та ефективності підтримки. 

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
1. PEP 8 – Style Guide for Python Code. URL: https://peps.python.org/pep-0008/ (дата звернення: 06.12.2024); 
2. PEP 257 – Docstring Conventions. URL: https://peps.python.org/pep-0257/ (дата звернення: 06.12.2024); 
3. Django Documentation. URL: https://docs.djangoproject.com/en/stable/ (дата звернення: 06.12.2024); 
4. Flask Documentation. URL: https://flask.palletsprojects.com/en/stable/ (дата звернення: 06.12.2024); 
5. Black – The Uncompromising Code Formatter. URL: https://black.readthedocs.io/en/stable/ (дата звернення: 06.12.2024); 
6. Flake8 Documentation. URL: https://flake8.pycqa.org/en/latest/ (дата звернення: 06.12.2024).

ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://youtu.be/0PVgIO0rXvc
Хронологічний опис відеозапису:
00:00 - 00:45 Вступ
00:45 - 02:30 Блок 1: Стильові рекомендації PEP 8
02:30 - 04:45 Блок 2: Методи рефакторингу
04:45 - 06:45 Блок 3: Професійні практики
06:45 - 07:30 Інструменти автоматизації
07:30 - 08:00 Висновки



ДОДАТОК Б
Слайди презентації

Рисунок Б.1 — Титульний слайд

Рисунок Б.1 — «Python у веб-розробці»

Рисунок Б.3 — «Проблематика презентації»

Рисунок Б.4 — Структура доповіді презентації 

Рисунок Б.5 — Загальні відомості про РЕР8

Рисунок Б.6 — Рекомендація 1, правила найменування

Рисунок Б.7 — Рекомендація 1, правила найменування, Приклад 1

Рисунок Б.8 — Рекомендація 1, правила найменування, Приклад2

Рисунок Б.9 — Рекомендація 2, Структура та форматування
Рисунок Б.10 — Рекомендація 2, Структура та форматування, Приклад 1


Рисунок Б.11 — Рекомендація 3, Організація імпортів

Рисунок Б.12 — Рекомендація 3, Організація імпортів, Приклад 1

Рисунок Б.13 —Загальні засади рефакторингу
Рисунок Б.14 — Рекомендація 4


Рисунок Б.15 — Рекомендація 4, приклад 1
Рисунок Б.16 — Рекомендація 5


Рисунок Б.17 — Рекомендація 5, Приклад 1

Рисунок Б.18 — Розгляд рекомендацій рефакторингу коду

Рисунок Б.19 —Рекомендація 6
Рисунок Б.20 — Рекомендація 6, Приклад 1

Рисунок Б.21 — Рекомендація 7

Рисунок Б.22 — Рекомендація 7, Приклад 1

Рисунок Б.23 — Рекомендація 8, Документування кодуРисунок Б.24 — Рекомендація 8, Документування коду, Приклад 1 
Рисунок Б.25 — Інструменти автоматизації 

Рисунок Б.26 — Опис засобів автоматизації

Рисунок Б.27 — Підсумки презентації

Рисунок Б.28 —Висновки презентації


Рисунок Б.29 — Подяка

16


