Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії



Звіт до практичного завдання №2
з дисципліни «Аналіз та рефакторинґ коду»
на тему: «Методи рефакторингу Фаулера у практиці веб-розробки на Python»







Виконав 	
ст. гр. ПЗПІ-23-3                                                               			Світенко С.М.
Перевірив
ст. викладач катедри ПІ 					Сокорчук І.П.





                                                                                     

Харків 2025
1 ІСТОРІЯ ЗМІН 
№ДатаВерсія звітуОпис змін та виправлень110.10.20250.1Написання розділу «Завдання»209.12.20250.2Написання розділу «Опис виконаної роботи»313.12.20251.0Завершено роботу над звітом


2 ЗАВДАННЯ
     Мета роботи: 
     Метою даної роботи є дослідження та систематизація практичних аспектів застосування стандарту PEP 8 та методів рефакторингу коду у контексті веб-розробки на мові програмування Python, а також визначення їх впливу на якість, читабельність та підтримуваність програмного забезпечення. Робота спрямована на вивчення основних принципів та рекомендацій стандарту PEP 8, який є загальноприйнятим керівництвом щодо стилю написання коду на Python, включаючи правила форматування, іменування змінних, функцій та класів, організації імпортів, обробки винятків та документування коду. Окрім того, метою є детальний аналіз різноманітних технік рефакторингу, таких як виділення методів, спрощення умовних конструкцій, усунення дублювання коду, оптимізація структури класів та модулів, які дозволяють покращити архітектуру існуючих веб-додатків без зміни їх зовнішньої функціональності. Важливим завданням роботи є демонстрація практичного застосування цих принципів у популярних Python веб-фреймворках, таких як Django та Flask, з наведенням конкретних прикладів рефакторингу коду контролерів, моделей, шаблонів та допоміжних функцій. Дослідження також має на меті показати, як дотримання стандартів кодування та регулярний рефакторинг сприяють покращенню командної роботи, полегшують процес Code Review, знижують кількість помилок у коді, прискорюють розробку нових функцій та спрощують підтримку проектів у довгостроковій перспективі. Кінцевою метою є формування комплексного розуміння того, як інтеграція правил PEP 8 та методів рефакторингу у процес веб-розробки на Python може суттєво підвищити професійний рівень розробників та якість створюваних ними продуктів.




3 ОПИС ВИКОНАНОЇ РОБОТИ
     У рамках практичної роботи було детально вивчено та проаналізовано методи рефакторингу Мартіна Фаулера для веб-розробки на Python. Робота базувалася на фундаментальній праці Мартіна Фаулера "Refactoring: Improving the Design of Existing Code" та офіційному стандарті PEP 8 Style Guide for Python Code. Практична частина включала детальне вивчення трьох ключових методів рефакторингу: Extract Method, Rename та Simplify Conditional Expression, а також використання сучасних інструментів автоматизації рефакторингу, таких як PyCharm, VS Code з Pylance, Ruff та Black.
3.1 Поняття рефакторингу та його значення
     Рефакторинг являє собою дисциплінований процес покращення внутрішньої структури програмного коду без зміни його зовнішньої поведінки та функціональності. Це один з фундаментальних принципів сучасної програмної інженерії, який дозволяє підтримувати якість кодової бази на високому рівні протягом усього життєвого циклу проекту. Мартін Фаулер, один з провідних експертів у галузі розробки програмного забезпечення та співавтор Agile Manifesto, систематизував понад сімдесят методів рефакторингу у своїй фундаментальній праці, яка вперше була опублікована у 1999 році та отримала оновлене видання у 2018 році. 
     Кожен метод має чітку назву, опис проблеми, покрокові інструкції застосування та приклади коду до і після рефакторингу. Важливість рефакторингу обумовлена кількома критичними факторами: код читається набагато частіше, ніж пишеться, тому його читабельність безпосередньо впливає на продуктивність команди; добре структурований код значно легше тестувати та підтримувати; рефакторинг попереджує накопичення технічного боргу, який може призвести до катастрофічного падіння швидкості розробки. 
     При проведенні рефакторингу необхідно дотримуватися чотирьох основних принципів: поведінка коду не повинна змінюватися ані на йоту; всі зміни виконуються маленькими покроковими інкрементами; тести є обов'язковими після кожного кроку рефакторингу для підтвердження збереження функціональності; рефакторинг має бути регулярною частиною процесу розробки, а не одноразовою подією.
3.2 Extract Method - виділення методу
     Одним з найбільш ефективних та найчастіше використовуваних методів рефакторингу є Extract Method, який полягає у виділенні фрагменту коду в окремий метод з описовою назвою. Цей метод застосовується у наступних ситуаціях: коли метод перевищує обсяг у двадцять-тридцять рядків коду; коли певна логіка повторюється у різних місцях програми; коли фрагмент коду потребує коментаря для пояснення свого призначення; коли код виконує кілька різних задач одночасно; коли важко зрозуміти що робить метод без детального аналізу; коли складно покрити метод тестами через його складність. 
     Техніка Extract Method надає численні переваги: код стає самодокументованим, оскільки назва методу чітко пояснює його призначення; виділений метод можна повторно використовувати з різних місць програми; кожен метод можна тестувати окремо, що спрощує написання та підтримку тестів; код читається як послідовна історія, де кожен крок зрозумілий; кожен метод має одну чітку відповідальність згідно з принципом Single Responsibility; процес налагодження стає простішим, оскільки проблему легше локалізувати у невеликому методі. Особливо важливим є застосування цієї техніки у веб-розробці, де view-функції у Django або обробники маршрутів у Flask часто виконують п'ять-шість різних операцій одночасно, таких як валідація даних, взаємодія з базою даних, обробка бізнес-логіки, формування відповіді та логування.

Приклад коду до рефакторингу демонструє типову проблему:
01  from flask import Flask, request, jsonify
02  from werkzeug.security import generate_password_hash
03  import re
04
05  app = Flask(__name__)
06
07  @app.route('/users', methods=['POST'])
08  def create_user():
09      data = request.get_json()
10
11      # Валідація email
12      if not data.get('email'):
13          return jsonify({'error': 'Email required'}), 400
14      if not re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', data['email']):
15          return jsonify({'error': 'Invalid email'}), 400
16
17      # Валідація пароля
18      if not data.get('password') or len(data['password']) < 8:
19          return jsonify({'error': 'Password must be at least 8 characters'}), 400
20
21      # Хешування пароля
22      hashed_password = generate_password_hash(data['password'])
23
24      # Збереження в базу
25      user = User(email=data['email'], password=hashed_password, name=data.get('name'))
26      db.session.add(user)
27      db.session.commit()
28
29      # Відправка email
30      send_email(data['email'], 'Welcome!', 'Thanks for registering!')
31
32      return jsonify({'id': user.id, 'email': user.email}), 201
     
     Цей код має критичні проблеми: обсяг методу перевищує тридцять п'ять рядків; п'ять різних відповідальностей змішано в одному місці; важко тестувати через необхідність мокування багатьох залежностей; логіка валідації дублюється і може знадобитися в інших місцях.
     Після застосування Extract Method код перетворюється на набір невеликих, зрозумілих методів:

01  @app.route('/users', methods=['POST'])
02  def create_user():
03      data = request.get_json()
04
05      validate_user_data(data)
06      hashed_password = hash_password(data['password'])
07      user = save_user(data['email'], hashed_password, data.get('name'))
08      send_welcome_email(user.email)
09
10      return jsonify({'id': user.id, 'email': user.email}), 201
11
12
13  def validate_user_data(data):
14      validate_email(data.get('email'))
15      validate_password(data.get('password'))
16
17
18  def validate_email(email):
19      if not email:
20          abort(400, 'Email required')
21      if not re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', email):
22          abort(400, 'Invalid email')
23
24
25  def validate_password(password):
26      if not password or len(password) < 8:
27          abort(400, 'Password must be at least 8 characters')
28
29
30  def hash_password(password):
31      return generate_password_hash(password)
32
33
34  def save_user(email, password, name):
35      user = User(email=email, password=password, name=name)
36      db.session.add(user)
37      db.session.commit()
38      return user
39
40
41  def send_welcome_email(email):
42      send_email(email, 'Welcome!', 'Thanks for registering!')
     
     Переваги відрефакторованого коду очевидні: головний метод складається лише з дев'яти рядків і читається як послідовна історія; кожна функція має одну чітку відповідальність; кожен метод можна легко тестувати окремо; код можна повторно використовувати в інших частинах додатку.
3.3 Rename - перейменування елементів коду
     Метод Rename є однією з найпростіших, але водночас найважливіших технік рефакторингу, оскільки хороша назва являє собою половину документації коду. Погана назва може призвести до серйозних непорозумінь, помилок та значного уповільнення розробки. Існує кілька чітких ознак поганої назви: для розуміння призначення елемента потрібен додатковий коментар; назва не відповідає реальній функції, яку виконує код; використовуються скорочення, які важко зрозуміти без контексту; застосовуються занадто загальні назви на кшталт data, info, temp або process; назва може ввести в оману майбутнього читача коду; назва не описує що саме робить код або для чого він призначений. Навпаки, ознаками хорошої назви є наступні характеристики: назва чітко описує що робить метод або що зберігає змінна; назва відповідає на питання "що" робить код і "чому" він це робить; назва зрозуміла навіть без додаткового контексту; назва відповідає конвенціям мови програмування; назва не містить зайвої або надлишкової інформації; назва є точною та конкретною, а не абстрактною. 
     Важливе правило рефакторингу стверджує: якщо для пояснення призначення елемента коду потрібен коментар, це є чітким сигналом до перейменування, оскільки назва має бути достатньо описовою сама по собі.

Приклад коду з незрозумілими назвами демонструє типові проблеми:
01  from django.db import models
02
03  class UserManager(models.Manager):
04      def get_data(self):
05          """Що повертає цей метод? Які дані? Незрозуміло!"""
06          return self.filter(
07              is_active=True,
08              orders__isnull=False
09          ).select_related('profile').distinct()
10
11      def proc(self, u_id):
12          """Що робить proc? Що таке u_id?"""
13          u = self.get(id=u_id)
14          u.last_login = timezone.now()
15          u.save()
16          return u
17
18      def get_list(self, params):
19          """Який список? За якими критеріями?"""
20          return self.filter(**params).order_by('-created_at')
     
     У цьому коді назви не описують що робить код; необхідні коментарі для розуміння; важко використовувати без додаткового вивчення реалізації.
Після застосування методу Rename код стає самодокументованим:
01  from django.db import models
02
03  class UserManager(models.Manager):
04      def get_active_users_with_orders(self):
05          """Назва точно описує: активні користувачі з замовленнями та профілями"""
06          return self.filter(
07              is_active=True,
08              orders__isnull=False
09          ).select_related('profile').distinct()
10
11      def update_last_login_time(self, user_id):
12          """Назва описує дію: оновлюємо час останнього входу"""
13          user = self.get(id=user_id)
14          user.last_login = timezone.now()
15          user.save()
16          return user
17
18      def get_users_sorted_by_registration_date(self, filter_params):
19          """Назва описує що повертаємо та як сортуємо"""
20          return self.filter(**filter_params).order_by('-created_at')

     Переваги відрефакторованого коду: код є повністю самодокументованим; коментарі більше не потрібні для розуміння базового призначення; легко зрозуміти що робить кожен метод без читання його реалізації.

3.4 Simplify Conditional Expression - спрощення умовних виразів
     Метод Simplify Conditional Expression призначений для спрощення складних умовних виразів з метою покращення читабельності коду та зменшення його цикломатичної складності. Існує кілька типових проблем, які вказують на необхідність застосування цього методу: вкладені конструкції if/else з трьома або більше рівнями вкладеності; використання подвійних заперечень на кшталт if not is_not_valid, які важко читати; дублікація однакових умов у різних гілках коду; складні тернарні оператори, які важко зрозуміти з першого погляду; змішування логічних операцій AND та OR без чіткої структури; висока цикломатична складність, яка ускладнює тестування. 
     Для вирішення цих проблем застосовується шість основних технік спрощення:
* Guard clauses (захисні вирази) дозволяють здійснити ранній вихід з методу при виявленні помилкових умов; 
* Extract condition передбачає винесення складної умови в окремий метод з описовою назвою; використання позитивних умов замість заперечень покращує читабельність; 
* Decompose conditional дозволяє розбити складну умову на кілька простих методів; 
* Replace nested conditionals with guard clauses передбачає заміну вкладеності на послідовні перевірки з раннім виходом; 
* Consolidate duplicate conditions об'єднує дубльовані умовні вирази.

Приклад коду зі складною вкладеністю демонструє критичну проблему:
01  from fastapi import Request, HTTPException
02
03  async def auth_middleware(request: Request, call_next):
04      token = request.headers.get('Authorization')
05
06      if token:
07          if token.startswith('Bearer '):
08              token = token[7:]
09              user = await get_user_by_token(token)
10              if user:
11                  if user.is_active:
12                      if user.has_permission(request.url.path):
13                          if not is_token_expired(token):
14                              return await call_next(request)
15                          else:
16                              raise HTTPException(401, 'Token expired')
17                      else:
18                          raise HTTPException(403, 'No permission')
19                  else:
20                      raise HTTPException(401, 'User not active')
21              else:
22                  raise HTTPException(401, 'Invalid token')
23          else:
24              raise HTTPException(401, 'Invalid token format')
25      else:
26          raise HTTPException(401, 'No token provided')

     Цей код має сім рівнів вкладеності, що робить його надзвичайно важким для читання та підтримки, а цикломатична складність досягає значення вісім.

     Після застосування Simplify Conditional Expression код трансформується наступним чином:
01  from fastapi import Request, HTTPException
02
03  async def auth_middleware(request: Request, call_next):
04      token = extract_token(request)
05      user = await validate_token(token)
06      validate_user_access(user, request.url.path)
07
08      return await call_next(request)
09
10
11  def extract_token(request: Request) -> str:
12      """Guard clauses - ранній вихід при помилці"""
13      token = request.headers.get('Authorization')
14      if not token:
15          raise HTTPException(401, 'No token provided')
16      if not token.startswith('Bearer '):
17          raise HTTPException(401, 'Invalid token format')
18      return token[7:]
19
20
21  async def validate_token(token: str):
22      """Валідація токена та користувача"""
23      user = await get_user_by_token(token)
24      if not user:
25          raise HTTPException(401, 'Invalid token')
26      if is_token_expired(token):
27          raise HTTPException(401, 'Token expired')
28      return user
29
30
31  def validate_user_access(user, path: str):
32      """Перевірка прав доступу користувача"""
33      if not user.is_active:
34          raise HTTPException(401, 'User not active')
35      if not user.has_permission(path):
36          raise HTTPException(403, 'No permission')

     Переваги відрефакторованого коду є суттєвими: вкладеність зменшена до одного рівня; цикломатична складність кожного методу дорівнює двом; кожен метод можна легко протестувати окремо; код читається як природна мова.
3.5 Інструменти автоматизації рефакторингу
     Сучасні інтегровані середовища розробки та спеціалізовані інструменти надають потужні можливості для автоматизації процесу рефакторингу Python-коду. 
     PyCharm є найпотужнішим інструментом для рефакторингу Python, що надає наступні можливості: Extract Method за допомогою гарячої клавіші Ctrl+Alt+M дозволяє автоматично виділити фрагмент коду в окремий метод; Rename через Shift+F6 безпечно перейменовує елементи з автоматичним оновленням всіх посилань; Extract Variable за допомогою Ctrl+Alt+V виділяє вираз у змінну; Inline через Ctrl+Alt+N вбудовує метод або змінну на місце виклику; Change Signature дозволяє безпечно змінювати сигнатури методів. PyCharm також включає вбудовану перевірку відповідності PEP 8, підтримку type hints та автоматичні виправлення для типових проблем. 
     VS Code з розширенням Pylance надає базовий набір можливостей рефакторингу: Extract Method для виділення коду в метод; Rename Symbol через клавішу F2 для перейменування елементів; Extract Variable для виділення виразів; Quick Fix через Ctrl+. для швидких виправлень. Pylance додає можливості перевірки типів та автоматичної організації імпортів. 
     Для автоматичного форматування коду використовуються спеціалізовані інструменти: 
* Black є опініонованим форматувальником, який автоматично приводить код у відповідність до стандартів за однією командою black .; isort автоматично сортує та організовує імпорти згідно з PEP 8; 
* Ruff є швидким сучасним лінтером, який замінює flake8 та pylint, надаючи набагато вищу швидкість роботи.

     Практичний приклад використання Extract Method у PyCharm демонструє наскільки просто можна провести рефакторинг: спочатку виділяється фрагмент коду, який потребує винесення в окремий метод; потім натискається комбінація клавіш Ctrl+Alt+M; IDE автоматично визначає необхідні параметри методу, створює новий метод з відповідною сигнатурою та замінює виділений код на виклик нового методу. Переваги використання IDE для рефакторингу включають: блискавичну швидкість виконання операції (два-три кліки); автоматичне визначення параметрів методу; перевірку синтаксису на всіх етапах; автоматичне оновлення всіх місць виклику при зміні сигнатури.
   

ВИСНОВКИ
     У результаті виконання практичної роботи було детально вивчено три ключових методи рефакторингу Мартіна Фаулера та їх застосування у веб-розробці на Python. Extract Method застосовується коли метод перевищує двадцять рядків або логіка повторюється у кількох місцях, дозволяючи розбити складний код на зрозумілі самодокументовані функції з чіткими обов'язками. Rename використовується коли назви елементів коду не відображають їх реальне призначення, що значно покращує читабельність та зменшує необхідність у коментарях. Simplify Conditional Expression застосовується для спрощення складних умовних конструкцій з вкладеністю понад три рівні, використовуючи техніки guard clauses та винесення умов в окремі методи. Рефакторинг має бути постійною практикою та невід'ємною частиною процесу розробки, а не одноразовою подією; необхідно думати про читабельність коду вже під час його написання; обов'язково виділяти час на рефакторинг під час code review; перед додаванням нової функціональності варто покращити існуючий код. Використання сучасних інструментів значно прискорює процес: PyCharm є найпотужнішим для Python-розробки; VS Code з Pylance надає легке та швидке середовище; Ruff та Black забезпечують автоматичне форматування; Mypy надає можливості перевірки типів. Золоте правило рефакторингу Мартіна Фаулера стверджує: рефакторинг не повинен змінювати зовнішню поведінку коду, тому завжди необхідно мати набір тестів перед початком рефакторингу для підтвердження збереження функціональності системи. 

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
1. PEP 8 – Style Guide for Python Code. URL: https://peps.python.org/pep-0008/ (дата звернення: 11.12.2024); 
2. PEP 257 – Docstring Conventions. URL: https://peps.python.org/pep-0257/ (дата звернення: 12.12.2024); 
3. Django Documentation. URL: https://docs.djangoproject.com/en/stable/ (дата звернення: 12.12.2024); 
4. Flask Documentation. URL: https://flask.palletsprojects.com/en/stable/ (дата звернення: 12.12.2024); 
5. Black – The Uncompromising Code Formatter. URL: https://black.readthedocs.io/en/stable/ (дата звернення: 10.12.2024); 
6. Flake8 Documentation. URL: https://flake8.pycqa.org/en/latest/ (дата звернення: 13.12.2024).

ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://youtu.be/C3wgrDjeWwA
Хронологічний опис відеозапису:
0:00–0:50 — Вступ та тема доповіді
0:50–2:10 — Поняття рефакторингу та його значення
2:10–3:10 — Мартін Фаулер та каталог методів рефакторингу
3:10–4:00 — Extract Method: теоретичні основи
4:00–5:30 — Extract Method: приклад до рефакторингу (Flask)
5:30–7:00 — Extract Method: приклад після рефакторингу
7:00–7:50 — Rename: принципи правильного іменування
7:50–8:40 — Rename: приклад до перейменування (Django ORM)
8:40–9:30 — Rename: приклад після перейменування
9:30–10:20 — Simplify Conditional Expression: теорія
10:20–11:50 — Simplify Conditional: приклад до рефакторингу (FastAPI middleware)
11:50–13:10 — Simplify Conditional: приклад після рефакторингу
13:10–14:00 — Інструменти для рефакторингу Python
14:00–14:40 — Практична демонстрація Extract Method у PyCharm
14:40–15:03 — Висновки та ключові takeaways


ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – 1 слайд презентації

Рисунок Б.2 – 2 слайд презентації


Рисунок Б.3 – 3 слайд презентації
Рисунок Б.4 – 4 слайд презентації


Рисунок Б.5 – 5 слайд презентації
Рисунок Б.6 – 6 слайд презентації


Рисунок Б.7 – 7 слайд презентації
Рисунок Б.8 – 8 слайд презентації


Рисунок Б.9 – 9 слайд презентації


Рисунок Б.10 – 10 слайд презентації


Рисунок Б.11 – 11 слайд презентації



Рисунок Б.12 – 12 слайд презентації


Рисунок Б.13 – 13 слайд презентації


Рисунок Б.14 – 14 слайд презентації



Рисунок Б.15 – 15 слайд презентації


Рисунок Б.16 – 16 слайд презентації


Рисунок Б.17 – 17 слайд презентації


Рисунок Б.18 – 18 слайд презентації


Рисунок Б.19 – 19 слайд презентації


Рисунок Б.20 – 20 слайд презентації

26


