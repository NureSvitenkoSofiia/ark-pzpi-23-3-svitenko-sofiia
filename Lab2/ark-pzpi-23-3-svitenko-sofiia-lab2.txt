Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії





Звіт до лабораторної роботи №2
з дисципліни «Аналіз та рефакторинґ коду»
на тему: «Програмна система для 3D-друку»







Виконала	
ст. гр. ПЗПІ-23-3                                                               			Світенко С.М.
Перевірив
ст. викладач катедри ПІ 					Сокорчук І.П.




                                                                                     
Харків 2025
1. ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень110.10.251Створено та опрацьовано діаграми214.11.252Створено програмну реалізацію серверної частини315.11.253Завершено з висновками


2. ЗАВДАННЯ
     Мета роботи: 
     Набути практичних навичок проектування та розробки серверної частини програмної системи з використанням сучасних архітектурних підходів та enterprise-шаблонів проектування; оволодіти технологіями C#, ASP.NET Core 10.0, Entity Framework Core та PostgreSQL; реалізувати RESTful API для управління 3D-принтерами та завданнями друку; застосувати багатошарову архітектуру з чітким розділенням відповідальності; вивчити інтеграцію із зовнішніми сервісами (slicing-інструменти, email-сповіщення) та набути досвіду роботи з реляційними базами даних.


3. ОПИС ВИКОНАНОЇ РОБОТИ
3.1. Вибір мови програмування та технологій
3.1.1. Обґрунтування вибору C# та .NET
     Для реалізації серверної частини системи управління 3D-друком було обрано мову програмування C# на базі платформи .NET 10.0. Вибір обумовлений наступними факторами:
* Висока продуктивність та оптимізована робота з пам'яттю завдяки компіляції в нативний код;
* Потужна система типів з підтримкою nullable reference types, що мінімізує помилки null-reference;
* Вбудована підтримка асинхронного програмування (async/await) для ефективної обробки IO-операцій;
* Розвинута екосистема бібліотек для роботи з базами даних, веб-API, файловими системами;
* Крос-платформність .NET Core дозволяє розгортати систему на Windows, Linux та macOS;
* Інтеграція з ASP.NET Core забезпечує продуктивну та масштабовану веб-архітектуру.
   ASP.NET Core обрано як фреймворк для побудови RESTful API, оскільки він надає:
* Вбудовану підтримку Dependency Injection;
* Middleware pipeline для централізованої обробки запитів;
* Потужні інструменти валідації та серіалізації даних;
* Інтеграцію з Swagger для автоматичної генерації документації API.
3.2. Вибір бази даних PostgreSQL

   Для зберігання даних обрано реляційну СУБД PostgreSQL з використанням ORM Entity Framework Core 10.0.1.  Обґрунтування вибору:
* Підтримка складних реляційних зв'язків між принтерами, матеріалами та завданнями друку;
* ACID-властивості для забезпечення цілісності даних;
* Розширені можливості індексування для оптимізації запитів;
* Відкритий вихідний код та відсутність ліцензійних обмежень;
* Підтримка JSON-типів для гнучкого зберігання додаткових даних.
Entity Framework Core забезпечує:
* Автоматичне відстеження змін сутностей;
* Міграції бази даних для версіонування схеми;
* LINQ для типізованих запитів до бази;
* Eager, Lazy та Explicit Loading для оптимізації завантаження пов'язаних даних.
3.2.1. Допоміжні бібліотеки та фреймворки
У проєкті використовуються наступні NuGet-пакети:
* Swashbuckle.AspNetCore (v10.0.1) - для генерації OpenAPI/Swagger документації;
* Npgsql.EntityFrameworkCore.PostgreSQL (v10.0.0) - провайдер PostgreSQL для Entity Framework.
   Ці бібліотеки забезпечують надійну роботу з файлами, документування API та ефективну взаємодію з базою даних.
3.3. Розробка архітектури програмної системи
3.3.1. Багатошарова архітектура

     Система побудована за принципом багатошарової архітектури з чітким розділенням відповідальності:
* API Layer (Controllers) відповідає за HTTP запити/відповіді
* Business Logic Layer (Services)  відповідає за Бізнес-логіка
* Data Access Layer (Repositories) відповідає за Робота з БД
* Database (PostgreSQL) відповідає за Зберігання даних
Переваги такої архітектури:
* Модульність - кожен шар має чітко визначену відповідальність;
* Тестованість - шари можна тестувати незалежно один від одного;
* Замінність - можна змінити реалізацію одного шару без впливу на інші;
* Масштабованість - легко додавати нову функціональність.
3.3.2. Шар API (Controllers)
Контролери розміщені в каталозі ApiControllers/ та відповідають за:
* Прийом HTTP-запитів від клієнтів;
* Валідацію вхідних даних;
* Делегування обробки до відповідних сервісів;
* Форматування відповідей у стандарті REST.
Реалізовані контролери:
* PrinterController - управління принтерами (пінг, оновлення статусу);
* PrintJobsController - управління завданнями друку (створення, перегляд);
* UsersController - управління користувачами (реєстрація).
   Усі контролери використовують атрибут [ApiController] для автоматичної валідації моделей  та стандартизованої маршрутизації через [Route("api/[controller]")].
3.3.3. Шар бізнес-логіки (Services)
     Сервіси інкапсулюють бізнес-логіку системи та розміщені в Infrastructure/Services/. 
Основні сервіси:
1. PrintJobService - управління життєвим циклом завдань друку:
* Створення нового завдання з валідацією доступності матеріалів;
* Автоматичний слайсинг STL-файлів у G-code;
* Розрахунок оціночної маси матеріалу та часу друку;
* Отримання списку доступних матеріалів з прив'язкою до принтерів.
2. PrinterService - управління станом принтерів:
* Реєстрація нових принтерів у системі;
* Обробка ping-запитів для моніторингу доступності;
* Управління чергою завдань для кожного принтера;
* Оновлення статусу завдань (початок, завершення, помилка).
3. UserService - управління користувачами:
* Реєстрація нових користувачів;
* Валідація унікальності email.
4. SlicerService - інтеграція з зовнішнім slicing-інструментом:
* Виклик процесу slicing для конвертації STL → G-code;
* Налаштування параметрів друку (висота шару, температура, заповнення);
* Моніторинг процесу з таймаутом для запобігання зависанню.
5. EmailService - відправка email-повідомлень:
* Сповіщення користувачів про завершення завдань друку;
* Інформування про помилки під час друку.
3.3.4. Шар доступу до даних (Repository)
     Реалізовано універсальний репозиторій GenericRepository<T>, який надає типові CRUD-операції:
* GetListByConditionAsync - отримання списку з фільтрацією, сортуванням, включенням зв'язків;
* GetSingleByConditionAsync - отримання однієї сутності за умовою;
* AddAsync - додавання нової сутності;
* UpdateAsync - оновлення існуючої сутності;
* DeleteAsync - видалення за умовою.
Особливості реалізації:
* Підтримка NoTracking-запитів для оптимізації read-only операцій;
* Split Query для запобігання cartesian explosion при завантаженні множинних зв'язків;
* Автоматичне встановлення CreatedOn та LastModifiedOn при збереженні;
* Централізована обробка DbUpdateException з маппінгом у доменні помилки.
3.4. Використання шаблонів проєктування
3.4.1. Repository Pattern
     Шаблон Repository абстрагує логіку доступу до даних від бізнес-логіки. 
Реалізовано через інтерфейс IGenericRepository<T>, що дозволяє:
* Тестувати бізнес-логіку незалежно від бази даних через mock-об'єкти;
* Змінювати реалізацію доступу до даних без зміни сервісів;
* Централізувати обробку помилок БД.
Приклад використання:
1: var materialResult = await _materialRepository
2:     .GetSingleByConditionAsync(m => m.Id == request.RequiredMaterialId);
3.4.2. Dependency Injection
     Усі залежності між компонентами керуються через вбудований DI-контейнер ASP.NET Core. 
Конфігурація в ConfigureBuilder.cs:
1: services.AddScoped<IUserService, UserService>();
2: services.AddScoped<IPrintJobService, PrintJobService>();
3: services.AddScoped<IPrinterService, PrinterService>();
4: services.AddScoped(typeof(IGenericRepository<>), typeof(GenericRepository<>));
Переваги:
* Слабка зв'язаність (loose coupling) між компонентами;
* Спрощене тестування через можливість підміни залежностей;
* Автоматичне керування життєвим циклом об'єктів (Scoped, Transient, Singleton).
3.4.3. Result Pattern
     Для обробки помилок використовується Result Pattern замість винятків.  Класи Result та Result<T> інкапсулюють успішний результат або помилки:
1: public class Result
2: {
3:     public bool IsSuccess { get; }
4:     public IEnumerable<Error> Errors { get; }
5:     
6:     public static Result Success() { ... }
7:     public static Result Failure(Error error) { ... }
8: }
Переваги:
* Явна обробка помилок без performance-витрат на exceptions;
* Типізовані помилки з кодами та описами;
* Можливість повернути кілька помилок одночасно;
* Зручні extension-методи для перетворення Result у HTTP-відповіді.

Приклад:
1: var result = await _printJobService.CreatePrintJobAsync(userId, request, stlFile);
2:   return result.Match(StatusCodes.Status201Created);
3.4.4. Service Layer Pattern
Усі контролери делегують бізнес-логіку до сервісів, що забезпечує:
* Повторне використання логіки в різних контролерах або фонових задачах;
* Тестування бізнес-логіки без створення HTTP-контексту;
* Можливість додавання транзакцій, кешування на рівні сервісів.
3.5. Побудова UML-діаграм
3.5.1. Діаграма варіантів використання (Use Case Diagram)
Система підтримує два типи акторів:
Користувач (User):
* Зареєструватися в системі;
* Отримати список своїх завдань друку із статусами;
* Створити нове завдання друку:
o Отримати список доступних матеріалів;
o Вибрати матеріал;
o Завантажити STL-файл.
IoT Клієнт (Printer):
* Пінгувати сервер для збереження статусу онлайн;
* Отримати наступне завдання з черги;
* Почати друк (відмітити статус "printing");
* Завершити друк з результатом (успішно/помилка);
* Відправити email про завершення користувачу.

Email-сервіс для надсилання повідомлень про завершення друку.
3.5.2. Діаграма бази даних (ER-діаграма)
Схема бази даних складається з п'яти основних таблиць:
USERS
  - id (PK) - унікальний ідентифікатор
  - email - електронна пошта (унікальна)
  - created_on, last_modified_on - аудит-поля
PRINTERS
  - id (PK)
  - name - назва принтера
  - status - поточний статус (online, offline, printing)
  - last_ping - час останнього ping-запиту
  - ip_address - IP-адреса для комунікації
  - created_on, last_modified_on
MATERIALS
  - id (PK)
  - color - назва кольору
  - color_hex - RGB-значення кольору
  - material_type - тип матеріалу (PLA, ABS, PETG)
  - density_g_per_cm3 - щільність для розрахунку маси
  - diameter_mm - діаметр філаменту (1.75 або 3.0 мм)
  - created_on, last_modified_on
PRINTER_MATERIALS (зв'язкова таблиця many-to-many)
  - id (PK)
  - printer_id (FK → PRINTERS)
  - material_id (FK → MATERIALS)
  - quantity_g - доступна кількість матеріалу в грамах
  - updated_at - час останнього оновлення
PRINT_JOBS
  - id (PK)
  - stl_file_path - шлях до вихідного STL-файлу
  - g_code_path - шлях до згенерованого G-code
  - required_material_id (FK → MATERIALS)
  - estimated_material_g - оціночна витрата матеріалу
  - actual_material_g - фактична витрата після друку
  - estimated_print_time_minutes - оціночний час друку
  - printer_id (FK → PRINTERS)
  - status - статус завдання (pending, printing, completed, failed)
  - error_message - опис помилки (nullable)
  - created_at, started_at, completed_at - часові мітки
  - requester_id (FK → USERS)


Зв'язки:
* USERS 1:N PRINT_JOBS - один користувач може створити багато завдань;
* PRINTERS 1:N PRINT_JOBS - один принтер виконує багато завдань;
* MATERIALS 1:N PRINT_JOBS - один матеріал використовується в багатьох завданнях;
* PRINTERS N:M MATERIALS через PRINTER_MATERIALS - принтер може мати кілька матеріалів.
3.6. Реалізація функціональних модулів
3.6.1. Модуль управління принтерами (PrinterService)
     Відповідає за реєстрацію принтерів, моніторинг їх стану та управління чергою завдань.
Основний функціонал:
* RegisterPrinterAsync - додає новий принтер у систему з перевіркою унікальності імені;
* PingAsync - оновлює last_ping та ip_address для моніторингу доступності;
* GetJobQueueAsync - повертає список завдань у статусі "pending" для конкретного принтера;
* StartJobAsync - змінює статус завдання на "printing" та фіксує started_at;
* FinishJobAsync - встановлює completed_at, оновлює actual_material_g та надсилає email;
* UpdateJobStatusAsync - дозволяє оновити статус та error_message.
Особливості реалізації:
* Валідація наявності принтера перед усіма операціями;
* Транзакційність при зміні статусів для забезпечення консистентності;
* Інтеграція з EmailService для автоматичного сповіщення користувачів.
3.6.2. Модуль управління завданнями друку (PrintJobService)
     Найскладніший модуль системи, що забезпечує повний життєвий цикл завдання друку.
Процес створення завдання (CreatePrintJobAsync):
1. Валідація вхідних даних:
* Перевірка існування матеріалу в БД;
* Перевірка доступності принтера;
* Перевірка наявності матеріалу на обраному принтері через таблицю PRINTER_MATERIALS.
2. Збереження STL-файлу:
* Генерація унікального імені файлу через GUID;
* Збереження у каталог, налаштований через конфігурацію (FileStorage:BasePath);
* Збереження шляху до БД для подальшого доступу.
3. Автоматичний слайсинг:
* Виклик SlicerService для конвертації STL → G-code;
* Передача параметрів матеріалу (діаметр філаменту);
* Обробка помилок слайсингу з детальним логуванням.
4. Аналіз G-code (CalculateGCodeEstimationsAsync):
* Парсинг G-code для підрахунку екструзії (команди G1 з параметром E);
* Розрахунок об'єму матеріалу: V = π * (d/2)² * L;
* Розрахунок маси: m = V * density;
* Оцінка часу друку на основі feedrate та відстаней переміщень.
5. Створення запису в БД:
* Збереження усіх шляхів, оцінок та прив'язок до принтера/матеріалу;
* Встановлення початкового статусу "pending".
6. Формування відповіді:
* Завантаження пов'язаних даних (Printer, Material) через Include;
* Створення DTO-об'єкта PrintJobResponse з усіма деталями
* GetAvailableMaterialsAsync - повертає усі матеріали з інформацією про доступність на принтерах.
3.6.3. Модуль користувачів (UserService)
     Базовий модуль для управління користувачами системи.
Функціонал:
RegisterUserAsync - реєстрація нового користувача:
* Перевірка унікальності email;
* Створення запису в таблиці USERS;
* Повернення RegisterUserResponse з присвоєним id.
3.6.4. Модуль слайсингу (SlicerService)
     Забезпечує інтеграцію з зовнішнім slicing-інструментом для перетворення 3D-моделей у G-code.
Процес слайсингу (SliceAsync):
1. Завантаження параметрів матеріалу з БД (діаметр філаменту);
2. Підготовка вихідного каталогу для G-code файлів;
3. Формування аргументів командного рядка:
* layer-height 0.2           # висота шару
* fill-density 20%           # відсоток заповнення
* filament-diameter <value>  # діаметр з БД
* temperature 200            # температура екструдера
* bed-temperature 60         # температура столу
* perimeters 3               # кількість периметрів
4. Запуск зовнішнього процесу з налаштуваннями:
* UseShellExecute = false для контролю процесу;
* RedirectStandardOutput/Error для логування;
* Timeout 10 хвилин для запобігання зависанню;
5. Моніторинг виконання:
* Захоплення output/error streams асинхронно;
* Перевірка ExitCode після завершення;
* Валідація створення вихідного G-code файлу;
6. Логування результатів та обробка помилок.
Особливості:
* Підтримка налаштування шляху до slicer через конфігурацію (Slicer:Path);
* Детальне логування для діагностики проблем;
* Таймаут для захисту від зависання на великих моделях.
3.6.5. Модуль електронної пошти (EmailService)
     Відповідає за відправку email-повідомлень користувачам про статус завдань друку.
Основна функція:
SendEmailAsync - відправка email з використанням SMTP, що надає GoogleSMTP.
Використання:
1:   await _emailService.SendEmailAsync(
2:       userEmail, 
3:       "Друк завершено", 
4:       $"Ваше завдання #{jobId} успішно надруковано");
Інтеграція в систему:
* Викликається з PrinterService.FinishJobAsync після завершення друку;
* Отримує email користувача через зв'язок PrintJob → User;
* Формує повідомлення з результатом (успіх/помилка).
3.7. Обробка помилок та логування
3.7.1. Глобальний обробник винятків (GlobalExceptionHandler)
Реалізує IExceptionHandler для централізованої обробки необроблених винятків:
* Логування помилок з деталями запиту (path, method);
* Формування стандартизованої Problem Details відповіді;
* Приховування внутрішніх деталей від клієнтів для безпеки.
Налаштовано через middleware:
1: services.AddExceptionHandler<GlobalExceptionHandler>();
2:   app.UseExceptionHandler();
3.7.2. Логування
     Використовується вбудований інтерфейс ILogger<T> для трасування, що розширено за допомогою бібліотеки Serilog:
* Створення завдань друку;
* Процеси слайсингу (старт, прогрес, результат);
* Аналіз G-code з деталями розрахунків;
* Помилки доступу до БД, файлової системи, зовнішніх процесів.
Рівні логування:
* Information - стандартні операції;
* Warning - не критичні проблеми (наприклад, файл slicer не знайдено);
* Error - критичні помилки з трасуванням стека.
3.8. Конфігурація та налаштування
Система використовує appsettings.json для централізованого налаштування:
01: {
02:     "ConnectionStrings": {
03:         "DataContext": "Host=localhost;Database=3dapi;Username=...;Password=..."
04:     },
05:     "FileStorage": {
06:         "BasePath": "C:\\3d",
07:         "StlFolder": "stl",
08:         "GCodeFolder": "gcode"
09:     },
10:     "Slicer": {
11:         "Path": "E:\\Programs\\Slicer\\slicer.exe"
12:     }
13: }
Переваги:
* Різні конфігурації для Development/Production через appsettings.{Environment}.json;
* Можливість override через змінні середовища;
* Типізований доступ через IConfiguration.
ВИСНОВКИ
     У ході лабораторної роботи було розроблено повнофункціональну серверну частину системи управління 3D-друком на базі технологій C# та ASP.NET Core 10.0. Реалізована  система демонструє застосування сучасних підходів до побудови enterprise-додатків з  використанням перевірених архітектурних шаблонів та best practices розробки.
     Основою системи стала багатошарова архітектура з чітким розділенням відповідальності між шарами Presentation, Business Logic та Data Access. Така організація забезпечила високу модульність, тестованість та можливість незалежної зміни реалізації окремих компонентів без впливу на інші частини системи. Застосовано класичні Enterprise-шаблони проєктування, зокрема Repository Pattern для абстракції доступу до даних, Dependency Injection для слабкої зв'язаності компонентів, Result Pattern для явної обробки помилок без performance-витрат на exceptions, а також Service Layer Pattern для інкапсуляції бізнес-логіки. Використання цих шаблонів дозволило створити maintainable code base, який легко розширювати та підтримувати.
     Розроблено п'ять ключових сервісів, що забезпечують управління життєвим циклом завдань друку від створення до завершення, автоматичний слайсинг STL-файлів у G-code з детальним аналізом та розрахунком оцінок, моніторинг стану принтерів через ping-механізм, керування чергою завдань для кожного принтера та сповіщення користувачів через email про завершення друку. Особливо важливим є модуль аналізу G-code, який парсить файли для точного розрахунку витрати матеріалу та часу друку на основі фізичних параметрів філаменту, таких як діаметр та щільність матеріалу.
     Спроєктовано нормалізовану реляційну схему PostgreSQL з п'ятьма таблицями та складними зв'язками many-to-many між принтерами та матеріалами. Використання Entity Framework Core забезпечило типізовані LINQ-запити замість сирого SQL, автоматичні міграції для версіонування схеми, ефективну роботу зі зв'язками через Eager та Split Query  завантаження, а також автоматичне встановлення аудит-полів при збереженні даних. Реалізовано інтеграцію з зовнішнім slicing-інструментом через процесну взаємодію з  повним контролем виконання, включаючи захоплення output та error streams, таймаути  для запобігання зависанню та валідацію результатів. Додано підтримку Azure Blob Storage для масштабованого зберігання файлів у хмарному середовищі.
     Впроваджено централізований GlobalExceptionHandler для обробки необроблених винятків  з формуванням стандартизованих Problem Details відповідей згідно з RFC 7807. Result Pattern на рівні сервісів забезпечує явну обробку помилок з типізованими кодами та  описами, що дозволяє клієнтським додаткам адекватно реагувати на різні ситуації.  Детальне логування через вбудований ILogger дозволяє трасувати виконання критичних  операцій та ефективно діагностувати проблеми в production-середовищі. Створено RESTful 
API з дотриманням стандартів HTTP-методів та статус-кодів, а інтеграція Swagger/OpenAPI  забезпечує автоматичну генерацію інтерактивної документації для спрощення розробки клієнтських додатків та тестування endpoints.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
     1. Fowler M. Patterns of Enterprise Application Architecture. Addison-Wesley 
   Professional, 2002. 560 с.
     2. Martin R. C. Clean Architecture: A Craftsman's Guide to Software Structure 
   and Design. Prentice Hall, 2017. 432 с.
     3. ASP.NET Core Documentation. URL: https://learn.microsoft.com/en-us/aspnet/core/ 
   (дата звернення: 10.10.2025 – 14.11.2025).
     4. Entity Framework Core Documentation. URL: 
   https://learn.microsoft.com/en-us/ef/core/ (дата звернення: 10.10.2025 – 14.11.2025).
     5. PostgreSQL Documentation. URL: https://www.postgresql.org/docs/ 
   (дата звернення: 10.10.2025 – 14.11.2025).

ДОДАТОК А
Відеозапис
Посилання на відеозапис: https://youtu.be/R2WdPiVnMeE
0:00-0:45 — Вступ та мета роботи 
0:45-1:45 — Архітектура та технологічний стек 
1:45-2:45 — База даних та ER-діаграма 
2:45-4:00 — Patterns та архітектурні рішення 
4:00-5:00 — Ключові сервіси системи 
5:00-10:00 — Практична демонстрація API (повний користувацький флоу) 
5:00-5:30 — Реєстрація користувача 
5:30-6:00 — Реєстрація принтера 
6:00-6:30 — Ping від принтера 
6:30-7:00 — Отримання доступних матеріалів 
7:00-8:00 — Створення завдання на друк 
8:00-8:30 — Отримання черги завдань 
8:30-9:00 — Початок друку 
9:00-9:30 — Завершення друку 
9:30-10:00 — Перегляд завдань користувачем 
10:00-11:00 — Особливості реалізації (SlicerService, аналіз G-code) 
11:00-12:00 — Висновки та результати 

ДОДАТОК Б
Графічні матеріали

Рисунок Б.1 – ER діаграма

Рисунок Б.2 – Структура бази даних

Рисунок Б.3 – UML-діаграма прецедентів





ДОДАТОК В
Програмний код
Програмний код знаходиться за посиланням
https://github.com/NureSvitenkoSofiia/ark-pzpi-23-3-svitenko-sofiia/tree/main/Lab2
20


